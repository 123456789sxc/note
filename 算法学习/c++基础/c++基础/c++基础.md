c++基础

#include <>  and  #include ""    的区别

<>里的头文件是标准库的头文件；  "" 里的头文件是 不属于标准库里的头文件，比如自己写的头文件

## 输入

1.读取数量不定的输入数据

预先不知道要输入多少个数时

```c++
 int n;
 while(cin >> n) //不断读取数据直到没有新输入或者输入数据类型不匹配为止
 {
     
 }
```



## 数据类型

| 类型     | 关键字 |
| :------- | :----- |
| 布尔型   | bool   |
| 字符型   | char   |
| 整型     | int    |
| 浮点型   | float  |
| 双浮点型 | double |
| 无类型   | void   |

| 类型                     | 位             | 范围                                                         |                                     |
| :----------------------- | :------------- | :----------------------------------------------------------- | ----------------------------------- |
| char                     | 1 个字节       | -128 到 127 或者 0 到 255                                    | char无符号还是有符号的取决于编译器  |
| unsigned char            | 1 个字节       | 0 到 255                                                     |                                     |
| signed char              | 1 个字节       | -128 到 127                                                  |                                     |
| unsigned int             | 4 个字节       | 0 到 4294967295                                              | unsigned int                        |
| [signed] int             | 4 个字节，32位 | -2147483648 到 2147483647，-21亿到21亿，-2e9到2e9            | 等价于int                           |
| unsigned short [int]     | 2 个字节       | 0 到 65,535                                                  | 等价于unsigned short                |
| [signed] short [int]     | 2 个字节       | -32768 到 32767                                              | 等价于short                         |
| [signed] long [int]      | 8 个字节，64位 | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，-9e18到9e18 | 等价于long                          |
| unsigned long [int]      | 8 个字节       | 0 到 18,446,744,073,709,551,615， 1.8e19                     | 等价于unsigned long                 |
| [signed]long long [int]  | 16个字节，64位 |                                                              | 等价于 long long，是在c++11中定义的 |
| unsigned long long [int] | 16个字节，64位 |                                                              | 等价于unsigned long long            |
| float                    | 4 个字节       | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |                                     |
| double                   | 8 个字节       | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |                                     |
| long double              | 16 个字节      | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |                                     |

## 字符串

也算学完了c++，找个时间看一下string的源码解析。[源码分析C++的string实现 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/267896855)

1. 头文件

```cpp
#include <string>
```

2. string的创建

```cpp
string s1;     //未初始化，默认是空字符串，即""
string s2 = "c plus plus";   //初始化
```

3. string与c语言字符串的区别

   **string是一个类，而char是基本数据类型**

   string类的字符串不以 字符'\0' 结尾

4. string的输入输出cin、cout

5. 访问string中的字符用下标运算符[]

   需要注意一个问题：s[i] 是什么类型的？

   ```cpp
   string s = "niubi666";
   ```

   

5. 字符串的拼接用运算符  + 或 +=

6. string类的成员函数

   1. replace

   ```cpp
   1. string& replace(size_t pos, size_t n, const char *s);//将当前字符串从pos索引开始的n个字符，替换成字符串s。pos是第一个
   
   2. string& replace(size_t pos, size_t n, size_t n1, char c); //将当前字符串从pos索引开始的n个字符，替换成n1个字符c
   
   3. string& replace(iterator i1, iterator i2, const char* s);//将当前字符串[i1,i2)区间中的字符串替换为字符串s
   ```

   replace()会对源字符串进行更改，另外，返回的也是修改后的字符串



## 条件运算符

`Exp1 ? Exp2 : Exp3;`   //条件判断语句

这个是个三元运算符，因为需要三个操作数

如果 Exp1 为真，则计算 Exp2 的值，且 Exp2 的计算结果则为该条件判断语句的值。如果 Exp1 为假，则计算 Exp3 的值，且 Exp3 的计算结果则为该条件判断语句的值。



<font size = 7>使用位运算符一定要加括号,不然卡死你 </font>

## 位运算符

| 符号 | 描述 | 运算规则                                                     |
| :--- | :--- | :----------------------------------------------------------- |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，对有符号数，补符号位（算术右移） |

什么是算术右移？什么是逻辑右移？

举例

```c++
int x;          // int 是 32位的，有符号数
x = 5 & 2;   // 5的二进制 00000……101   ， 2的二进制000000……010  
             // 101 & 010 对应位相与，得到  000……000  ， 000的十进制是0，即x=0
```



```c++
int x = 5;       // int 是 32 位的，且是有符号数
int y = x >> 1;  //  x所有位右移1
				//  5的二进制 0……101 全部右移1，高位补符号位0， 即 0……010
// y = x / 2   等价于  x >> 1
```

$$
\frac{x}{2^n} = x >> n
$$

对于左移右移运算符

```cpp
int n = 5;
int t = n >> 1;
cout << t << n;

// t = 2
// n = 5
```

**说明左移右移运算符不会改变本身，返回值是运算结果**

比如，看一下，数字x的第k位     (x>>k)&1;

## lowbit()

`lowbit` 函数是一种位运算操作，用于计算一个整数的二进制表示中最低位的1所对应的值。其返回结果为一个整数，等于该整数对2取模的结果。例如，`lowbit(6)` 返回值为 `2`，因为6的二进制为 `110`，最低位为 `2^1`，所以结果为 `2`。

C++标准库中没有`lowbit`这个函数，但是可以通过位运算实现。`lowbit(x)`的功能是返回二进制表示中最低位1的位置对应的数值。

```cpp
int lowbit(int x) {
  return x & -x;
}
```

`lowbit` 函数常用于树状数组等算法中，用于快速定位一个整数二进制表示中最低位的1所对应的值。在树状数组中，每个元素的值都依赖于其下标对应的二进制表示中最低位的1所对应的值。因此，通过 `lowbit` 函数可以快速计算出元素下标所依赖的最低位1所对应的值，从而方便地实现树状数组的相关操作。

目前还不知道有什么用，先学会吧



lowbit()函数的实现利用了 数据以补码的形式存储 的特点。



补码的形式：最高位是符号位，以32位的为例

最高位为0的时候，表示正数，最高位为1的时候，表示负数，正数的最大值是 0111111111... 后面全是1，即$2^{31}-1$

在+1的话就成 1000000... ，此时为最小的负数 $-2^{31}$  

10000... + 0111111...  =  1111111.... 

对应十进制为  $-2^{31}+2^{31}-1 = -1$  即  1111111... = -1   再加1的话,变成全0 ,对应十进制的0

总结:从全0开始加1,正数一直增大,增大到01111...时为最大正数,再加1,成100000...  最小负数,  在这个基础上继续加1,数值逐渐变大,向0靠近,直到全1的时候,为-1,再加1就全0,对应十进制的0



对应的 x  和  -x 

x + (-x)  = 0  对应二进制就是 二进制的和为 全0

举个例子  x = 5 = $...000000000101_2$   那么对应的 -x 的二进制就可以写出来了, $-x = ....1111011_2$

根据 与运算符 `&` 全1才1,  5&(-5) =  $...00001_2$ = $01_2 = 1_{10}$

正好对应 $5$ 的最低位的1



最低位的1对应的负数的二进制同位置也是1，这样就可以产生进位，而高位是相反的，这样才能一直产生进位，才能全为0，因此，与运算相反数，得到的就是最低位的1，高位是相反的，为0，这位相同且都为1。



lowbit()的应用：计算整数n的二进制形式中1的个数

```cpp
int main()         //法一
{
    int n,t = 0;
    cin >> n;
    for(int i = 0;i < 32;i++) t += (n >> i)&1;
    cout << t << endl;
}
int lowbit(int x)
{
    return x & (-x);
}
int main()           //法二比法一好
{
    int n,t = 0;
    cin >> n;
    while(n) n -= lowbit(n),t++;
    cout << t << endl;
}
```



## 逻辑运算符的短路效应

```cpp
if(A && B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A && B 为 false

if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true
```



## 文件重定向

[C语言--文件重定向_文件重定向是什么意思_墨上烟雨的博客-CSDN博客](https://blog.csdn.net/weixin_42704090/article/details/86657886)

在测试程序的时候，可能会反复从键盘上敲入数据，如果你不想反反复复地敲入数据的话，可以使用文件重定向命令。(文件重定向命令是操作系统的)

大多数**操作系统支持文件重定向**，这种机制能够 由==键盘输入==变为由==文件输入==，由==输出到屏幕==变为==输出到文件==

1. 重定向运算符有两个  <    >
2. 重定向输入命令  `xxx.exe < file`
3. 重定向输出命令  `xxx.exe > outfile`
4. 组合重定向命令  `xxx.exe < file > outfile`

说明：

1.  `xxx.exe` 是可执行程序，`file`是输入文件名，里面存放输入的数据； `outfile`是输出文件名，里面存放程序执行后的输出。
2. 在Windows系统下，这些命令中的 `xxx.exe` 是 `xxx.exe` ；在Linux系统下，`xxx.exe` 应该变为 `xxx`
3. 可执行程序，输入文件，输出文件应该在同一目录下
4. 输入文件名和输出文件名不能一样
5. 重定向运算符连接一个可执行文件和一个数据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个可执行程序和另一个可执行程序；



举例实践：

我电脑上没有vs了，用dev-c++实现一下，

```c++
#include <stdio.h>

int main() {
	char ch;

	while ((ch = getchar()) != EOF) {
		putchar(ch);
	}

	return 0;
}
```

输入上述代码，然后编译，会生成一个exe文件

![1679977030413](c++基础.assets/1679977030413.png)

在当前目录下，新建两个txt文件

![1679977113848](c++基础.assets/1679977113848.png)

在input.txt中输入并保存。

![1679977210619](c++基础.assets/1679977210619.png)

在当前目录下，打开cmd

![1679977255002](c++基础.assets/1679977255002.png)

输入命令：

![1679977315879](c++基础.assets/1679977315879.png)

打开output.txt查看是否成功

![1679977369709](c++基础.assets/1679977369709.png)

## 引用

```c++
int i = 1;
```

这条语句做了两件事：

1. 开辟一个int空间分配给变量$i$，相当于给这片空间取了个名字叫$i$
2. 将1存放到这片空间。

```c++
int& r = i;
```

创建了一个变量$i$的引用$r$，$r$是这片空间的另一个名字.



引用和指针的区别：

1. 引用必须在创建的时候就初始化；指针没这个必要

2. 引用不能更改，指针可以修改

- 比如

  ```
  int i,j;
  int& r = i;
  int& r = j; //这条语句会报错，因为引用不能修改
  ```

3. 指针可以指向NULL,引用必须有对应空间。

**可以把引用理解为受限制的指针，指针相较于引用更加灵活。**

## 新for循环表示

```cpp
for(auto i in 容器)  // i是容器的每一个元素
{
    
}
```

等价python中的循环👇

```python
for i in 容器:
    
```



