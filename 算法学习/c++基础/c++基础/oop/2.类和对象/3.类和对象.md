第三章 类和对象

# 3.1类与对象的基本概念

## 3.1.1结构体和类

### 1.结构体的扩充

结构体是c语言一种自定义的数据类型，在结构体中可以含有不同类型的数据。

在c++中对结构体进行了扩充，不仅可以就含有不同类型的数据，而且还可以含有函数。

我们称结构体中的变量为数据成员，称结构体中的函数为成员函数

下面举一个例子来说明结构体的使用方法

```cpp
struct Complex{   //声明了一个名为Comeplex的结构体，表示复数
    double real;   //复数的实部
    double imag;   //复数的虚部
    void init(double r,double i)   //结构体的初始化函数
    {
        real = r;
        imag = i;
    }
    double abs()                   //求复数的绝对值
    {
        double t;
        t = real*real+imag*imag;
        return sqrt(t);
    }
}

int main()
{
    Complex A;
    A.init(1.1,2.2);
    cout << A.abs();
}
```



注意：这只是结构体的简单使用，其实结构体和类的区别很小。

结构体和类有什么区别？

结构体被设计出来的目的是为了存储一组相关的数据；而类被设计出来的目的是

通过将一组相关的数据和函数放在一个类中，可以使代码更加模块化和可维护。类可以将数据和函数封装起来，防止数据被不合理地修改，同时提供更好的数据安全性和访问控制。类还可以支持继承和多态，使得代码更加灵活和可扩展。

但是c++扩展之后，结构体相当于类的一个对称。

### 2.类的声明

c++提供了另一种用户自定义的数据类型——类。

```cpp
//类声明的一般形式

class 类名
{
    [private:]
    	数据成员和成员函数
    public:
    	数据成员和成员函数
}
```

类将数据成员和成员函数分为三类，private、public，私有和公有。

对于私有成员来说，它们只能被本类的成员函数看得到，即能够被本类的成员函数访问。不能被类外访问

对于公有成员来说，它们不仅可以被本类的成员函数访问，也能被该类的对象访问，即可以被类外访问。

> 综上可知，在类的内部，类中的任何成员 都可以被 本类的成员函数访问。

**访问就是能被看见，能被使用。**

> 结构体也有同样的性质👆

```cpp
struct 结构体名
{
    [public:]
    	数据成员和成员函数
    private:
    	数据成员和成员函数
}
```



在结构体中，如果对其成员不作private和public的声明，默认为public;在类中，默认为private





对类的理解：

我们可以把类看成是一个房子，在类的内部有数据成员和成员函数，我们可以把数据成员看成是工具，把成员函数看成是某种职业的人。

在类内部，也就是站在房子里，对于成员函数来说，也就是对于人来说，所有的工具和人都是可以看见的，也就是可以拿来使用的或调用的，比如说，把某个工具拿到就是用this（有同名变量的情况下），或者直接用（没有同名变量的情况下），不用管定义的先后顺序。

```cpp
class A
{
    public:
    	void mid(int x)  //在mid函数中有变量x，
        {
            this->x = x; //在函数中使用x会优先使用形参，这时候要想用类的数据成员x就要用this指针。
        }
    private:
    	int x;  //虽然数据变量x在后面定义的，但是在类中不管先后。
}
```

可以看见，意思就是可以访问的。只有人能 “看见”，也就是说人能访问工具或者其他人，但是工具不能 “看见”，工具不能访问其他工具或人

调用某个成员函数相当于请某个人来帮忙。那个人也可以使用房间里的任何工具或请其他人来帮忙。

类相当于构建了房子的结构，而对象相当于一个真实的房子。

创建一个某个类的对象，相当于我们按照类给出的房子结构建造了一个真正的房子。

创建一个房子之后，我们站在房子外面，看这个房子，相当于我们看一个插板。我们能看到的 房子里 的工具和人就是插板上的插口，我们把这些可以在外面看到的数据成员和成员函数称为接口。

我们在外面能看到什么由private、public决定。

如果类的数据成员和成员函数被定义为private，那么我们站在房子外面，看不到这些数据成员和成员函数。看不到就无法访问，无法调用。

public，站在房子外，我们能看到。

在不讨论派生类的前提下，protected相当于private



## 3.1.2成员函数的定义形式

成员函数有三种定义形式：

1. 类外定义，类内声明
2. 类内定义，隐式内联
3. 类外定义，显示定义为内联，类内声明

```cpp
class Point
{
    public:	
    	void setpoint(int a,int b);   //类内声明成员函数
    private:
    	int x,y;
}

void Point::setpoint(int a,int b)    //类外定义
{
    x = a;
    y = b;
}
```

这种类外定义，类内声明的方式减少类体的长度，使类的声明简洁明了，便于阅读。

```cpp
class Point
{
    public:
    	void setpoint(int a,int b)   //类内直接定义，隐式内联
        {
            x = a;
            y = b;
        }
    private:
    	int x,y;
}
```



```cpp
class Point
{
    public:	
    	void setpoint(int a,int b);   //类内声明成员函数
    private:
    	int x,y;
}

inline void Point::setpoint(int a,int b)    //类外定义,显式内联
{
    x = a;
    y = b;
}
```

> 跟结构体一样



## 3.1.3对象的定义和使用

### 1.类和对象的关系

类和对象的关系相当于，数据类型和变量名之间的关系。

### 2.对象的定义

定义对象的两种方法：

1. 声明类的同时定义对象
2. 类声明之后，定义对象

> 跟结构体一样

```cpp
class Point
{
    public:
    	void setpoint(int,int);
    private:
    	int x,int y;
}op1,op2;   //声明类的同时定义了两个该类的对象
```

### 3.对象对成员的访问

对象只能对类的公有成员进行访问，有以下三种方法：

1. 通过点运算符 `对象名.数据成员名`  `对象名.成员函数名()`
2. 通过 `->` ，指向对象的指针
3. 通过 \*号和 点运算符 `(*p).数据成员`



# 3.2构造函数和析构函数

1. 我们声明变量的时候常常会进行初始化，如果不进行初始化的话，取值就是随机的。

   同样，我们声明对象也会对对象的数据成员进行初始化。

2. 另一方面，我们声明变量的时候会给变量分配内存空间，{}结束时或遇到delete时会释放空间

   ```cpp
   int i;   //程序编译时分配给变量i 一个int的空间,在{}结束时被释放,变量i被删除。
   ```

   ```cpp
   int *a = new int[n];  //程序运行时被分配给变量i n个连续的int的空间
   //遇到delete a;时n个连续的int空间被释放，指针a直到{}结束时被删除
   ```

   

   同样，我们声明对象的时候，也会给对象的数据成员分配空间，{}结束时或遇到delete时会释放空间

   

在c++中，每一个类都有自己的构造函数和析构函数，这两个函数可以由用户自定义，也可以由系统生成。如果用户没有定义构造函数和析构函数，系统就会生成默认的构造函数和析构函数。如果至少存在一个构造函数，系统就不再提供默认的构造函数，为什么是 “存在至少一个”，因为构造函数可以重载。析构函数不同，一个类中只能有一个析构函数。

对于默认的构造函数和析构函数，不带任何参数，函数体是空的，只能为对象分配内存空间和释放内存空间。

构造函数会在声明类的对象的时候自动调用。构造函数用来为类的对象分配空间和进行初始化。构造函数是在声明对象的时候自动调用，我们在定义构造函数的时候可以不止为对象分配空间和进行初始化，还可以进行一些其他的操作。

析构函数会在对象被释放的时候自动调用。析构函数用来释放掉对象占用的内存。

3. **当类的数据成员中存在需要动态分配内存的变量时**，我们必须自定义构造函数，给其分配内存空间，在析构函数中释放掉。不能使用默认的构造函数和析构函数

## 3.2.1对象的初始化和构造函数

类是一种数据类型，不占存储空间，因此不能在类声明中给数据成员赋初值。

如果一个类的所有数据成员都是公有的，可以这样做

```cpp
class Complex
{
    public:
    	double real;
    	double imag;
};

Complex c = {1.1,2.1};
```

只要有数据成员不是公有的，就不能用这种方法。

也可以使用类的公有成员函数进行初始化

```cpp
class Complex
{
    public:
    	void init(double ,double );
    	double real;
    	double imag;
};

void Complex::init(double a,double b)
{
    real = a;
    imag = b;
}
int main()
{
    Complex c;
    c.init(1.1,2.1);
    cout << c.real << ' ' << c.imag;  // 1.1   2.1
}
```

c++提供了更好的方法，使用构造函数

如果我们不自定义构造函数和析构函数的话，默认的构造函数和析构函数的权限修饰符是public，因此，我们自定义构造函数和析构函数的话也要是public，不能是private，因为这样在声明对象的时候就不能调用构造函数了。

**构造函数的名字必须与类名相同，可以有任意类型的参数，但是不能有返回值。**

```cpp
class Complex
{
    private:
    	double real,imag;
   	public:
    	Complex(double r,double i)   //构造函数也是成员函数，定义成员函数有三种方法，这里取其中一种
        {
            real = r;
            imag = i;
        }
};

int main()
{
    Complex c(1.1,2.1);
    Complex *p = new Complex(1.1,2.1);
    //声明对象和初始化的两种方法👆
}
```

不带参数的构造函数对对象的初始化是固定的

```cpp
class Complex
{
    private:
    	double real,imag;
   	public:
    	Complex()
        {
            real = 0;
            imag = 0;
        }
};
```



## 3.2.2用成员初始化列表对数据成员初始化

举个具体的例子

```cpp
class Complex
{
    private:
    	double real;
    	double imag;
    public:
    	Complex(double r,double i):real(r),imag(i){}
};


```

其中 `：real(r),imag(i)` 就是成员初始化列表。冒号后面跟 `数据成员名(初始值),数据成员名(初始值),...`

成员初始化列表只能在构造函数中使用，在其他成员函数和类外都不能使用

成员初始化列表写法方便简练、更装逼。但其实也是有实际用途的。

对于c++的某些类型的成员，不能用赋值语句赋值，比如 引用类型，const修饰的数据成员。这时候就要用成员初始化列表了。

数据成员的初始化是按照它们在类中声明的顺序进行的。举例：

```cpp
class D
{
    public:
    	D(int i):mem2(i),mem1(mem2+1)
        {
            cout << "mem1" << mem1 <<endl;
            cout << "mem2" << mem2 << endl;
        }
    private:
    	int mem1;
    	int mem2;
};

int main()
{
    D d(15);
}

输出结果：
mem1: -858993459
mem2: 15
```

**其实看成员初始化列表会觉得是先给mem2赋初值，再给mem1赋初值。实际上是根据数据成员在类中的声明顺序进行的初始化**。因此正确的初始化顺序是先给mem1赋初值，再给mem2赋初值。这样就可以解释的通了，因为在给mem1赋初值的时候，mem2还没被初始化。



## 3.2.3构造函数的重载



## 3.2.4带默认参数的构造函数

不建议用，别用这玩意儿，给自己找麻烦，没需求不要创造需求。



## 3.2.5析构函数

析构函数与类名相同，但是必须在它前面加一个波浪号(~）

析构函数没有返回值

析构函数没有参数，不能重载

释放对象的时候会自动调用析构函数

如果在对象释放之前需要完成一些工作的话，可以显式定义析构函数，并写入到析构函数中，比如delete在构造函数中new分配的内存空间。

```cpp
class String_data
{
    public:
    	String_data(char* s)
        {
            str = new char[strlen(s)+1];
            strcpy(str,s);
        }
    	~String_data()
        {
            delete str;
        }
    private:
    	char *str;
}
```



# 3.3对象数组和对象指针和this指针

对象数组就是数组的每一个元素都是一个对象。

在创建对象数组的时候要给数组开辟空间，因此，在创建对象数组的时候就要进行初始化。数组有多少个元素就要调用多少次构造函数

如果构造函数只有一个，且是自己自定义的，而且构造函数的参数只有一个。

```cpp
类名 数组名[3] = {1,2,3};
```

可以像上面一样：创建数组的时候必须给每一个对象传构造函数的参数



如果要求对象的初始值都相同，可以自己定义一个不带参数的构造函数或者带有默认值参数的构造函数。如果对象的初始值要求不同，按照需求来，多定义几个构造函数。

这种情况的话，最好是按照常规的来，不要取巧。下面是常规方法

```cpp
Complex c[3] = {
    Complex(1.1,2.1);
    Complex(3.1,3.1);
    Complex(2.1,2.1);
};
//明显这种方法更合适。
```



对象指针就是对象指针，没有一点特殊的地方。



**this指针**

当定义了若干个对象之后，会给每一个对象分配存储空间。如果一个类既有数据成员，也有成员函数，就要分别给数据成员和成员函数分配存储空间。事实上，同一个类的每个对象的成员函数是一样的，没必要给每个对象的成员函数都分配空间。实际上，c++只用一段空间来存放一个类的成员函数。每个对象的存储空间只是该对象的数据成员的存储空间。

一个类的每个对象都有属于自己的数据成员，但是所有对象的成员函数却合用一份。

**当某个对象调用成员函数的时候，成员函数根据this指针来访问该对象的数据成员**

this指针是隐含参数

```cpp
class A
{
    public:
    	A(int x1)
        {
            x = x1;
        }
    	void disp()
        {
            cout << x << endl;
        }
    private:
    	int x;
};

int main()
{
    A a(1);
    a.disp();
}
```

在 `a.disp()`中对象a调用了成员函数disp()；实际上是下面这样的

```cpp
class A
{
    public:
    	A(int x1)
        {
            x = x1;
        }
    	void disp(A* this)  //this指针是指向类A的对象的指针,注意不要这样写，因为this指针由系统已经定义好了，不要在这里写 A* this
        {
            cout << this->x << endl;  //直接用就好了，这样 this->x  是可以的
        }
    private:
    	int this->x;
};

int main()
{
    A a(1);
    a.disp(&a);     //注意，写代码的时候使用&a会报错，自己知道是这样的就好了。
}
```

这样成员函数就可以根据this指针找到对象a的地址，从而对对象a的数据成员进行操作。

this指针默认是隐式的，我们写代码的时候可以显示出来。this指针下面的一个应用：

`this`指针可以用来区分局部变量和成员变量。在一个成员函数中，如果有一个局部变量和一个成员变量的名字相同，可以通过使用`this`指针来指定访问成员变量，例如：

```cpp
class MyClass {
public:
    void setX(int x) {
        this->x = x;
    }
private:
    int x;
};
```

在上面的代码中，`setX`函数中的`x`参数和`MyClass`类中的`x`成员变量具有相同的名称，通过使用`this`指针可以将参数值赋值给成员变量。

# 3.4向函数传递对象

## 3.4.1使用对象作为函数参数

值传递，只把值给传过去了，本身不会受到任何影响。

## 3.4.2使用对象指针作为函数参数

地址传递，会影响本身。

## 3.4.3使用对象引用作为函数参数

之前谈过 引用和指针的关系，总的来说，引用具有指针的功能，而且还比指针好用。

所以说，传递引用就是传递本身。

# 3.5对象的赋值和复制

## 3.5.1 对象的赋值语句

```cpp
class A
{
    public:
    	A(int a,int b):x(a),y(b){}
    private:
    	int x,y;
};

int main()
{
    A a(1,2),b(2,1);
    a = b;          // 对象赋值语句
    //等价于
    // a.x = b.x;
    // a.y = b.y;
}
```

**使用对象赋值语句，就是把后者的数据成员赋值给前者对应的数据成员。**

建议只在同类的不同对象使用，不要花里胡哨用在两个不同类的两个对象上。

有一点需要考虑的是，如果数据成员中有const修饰的数据成员或者引用的数据成员，应该就不能用赋值运算符了。

另一点是，如果数据成员中有指针，也需要注意，如果使用赋值运算符的话， 会让两个对象的数据成员——指针

指向同一个地址，如果这个指针指向的空间被释放掉了，那么另一个对象的那个指针还是指向那个地址，不会报错，但空间确实没了。这种问题需要小心。

举个例子

```cpp
class A
{
    public:
    	void init(int *a)
        {
            p = a;
        }
    private:
    	int *p;
};

int main()
{
    int *a = new int;
    A s,b;
    s.init(a);
    b = s;
    delete a;
}
```

这种其实还好说，自己写代码的时候知道自己把内存delete了，知道俩对象的数据成员p指向的内存没有意义了。但是有些时候，就不容易发现了。

以上部分属于[类的赋值运算符](../运算符重载/运算符重载)的内容



**对于数据成员中含有指针的，而我们又需要copy已经存在的对象的数据成员到一个新的对象里，这时候就需要用到拷贝构造函数了。**

## 3.5.2拷贝构造函数

拷贝构造函数是一种特殊的构造函数。

**拷贝构造函数的形参是本类对象的引用**，拷贝函数的作用就是在建立新对象p2时，用已经存在的对象p1去初始化新对象p2，在这个过程中就要调用拷贝构造函数。

```cpp
Point p2(p1);
```

拷贝构造函数的特点：

1. 拷贝构造函数是一种构造函数，函数名就是类名，没有返回值类型。
2. 只有一个参数，只能是本类对象的引用
3. 每个类都有拷贝构造函数，程序员可以自定义，用于按照需要进行初始化。如果没有自定义，系统会默认生成默认的拷贝构造函数。默认的拷贝构造函数就是数据成员的复制

先看程序员自定义拷贝构造函数，

```cpp
类名::函数名（const 类名 &对象名）  //使用类外定义的方式，其他方式也可以
{
    //构造函数的函数体
}
```

我们的形参要求是本类对象的引用，我们的目的是用已经存在的对象去初始化新的对象，并不希望已经存在的对象有所改变，所用加上const保险。



调用拷贝构造函数的两种形式：

1. 代入法
2. 赋值法

```cpp
类名 对象2（对象1）；  //代入法
类名 对象2 = 对象1；  //赋值法
```

关于赋值法，看着有点像对象赋值语句。但其实是调用了拷贝构造函数，把两者区分看。

**对象赋值语句并不是调用了拷贝构造函数，而是调用了赋值运算符重载函数。拷贝构造函数用于初始化一个对象，而赋值运算符重载函数用于将已有对象的值赋给另一个对象。**

赋初值和初始化 是两个不同的概念

初始化是在创建的同时赋初值。

对象赋值语句是赋值，拷贝构造函数是初始化。



调用拷贝构造函数的三种情况：

1. 用已经存在的对象去初始化新对象
2. 函数的参数是类的对象的时候。
3. 函数的返回值是类的对象的时候。

对于第一种，都了解，不举例子了。

```cpp
class Point
{
    public:
    	Point(int a,int b):x(a),y(b){}
    private:
    	int x,y;
};

void fun(Point p)  //定义了一个形式参数是类的对象 的函数
{
    cout << p.x << endl;
}

int main()
{
    Point p(1,2);
    fun(p);
    return 0;
}
```

其实也很好理解，把对象看成一般的变量就可以了，我们知道，在函数传参的时候，进行值传递的时候，系统是这样做的，在函数内声明一个形参变量，然后将实参的值都传给形参变量。也就是为什么叫值传递。

上面的fun函数也是一样的，在执行fun函数的时候，系统声明了一个Point类的对象p，然后将实参的值复制一份给形参，这个复制的过程调用的就是拷贝构造函数。



同理，第三种情况也是一样的。

```cpp
Point fun()
{
    Point p1(1,3);
    return p1;
}

int main()
{
    Point p2;
    p2 = fun();
}
```



在fun函数返回Point类对象p1的时候，会在调用函数的地方创建一个临时对象，将p1复制一份给临时对象的时候调用的就是拷贝构造函数，将临时对象赋值给p2的时候使用的是对象赋值语句。当执行完调用函数**那一行**命令之后，临时对象就被释放掉了。

# 3.6静态成员

静态是一种什么意思呢？被 `static` 修饰的变量成为静态的。静态与动态相对。

我们先聊一下什么是动态的。

在程序运行的时候根据需要分配内存和释放内存。

局部变量就是动态的，因为程序在运行到声明局部变量的时候，给变量分配了内存，在出了块作用域的时候就被释放掉了。

我们经常遇到的有两种：

```cpp
int i = 0;
```

```cpp
int *a = new int(0);
```

这两种都是在声明变量，只是一种是程序自动识别数据类型分配相应的内存，另一种是程序员使用new运算符分配内存空间。这两种的唯一区别体现在两个方面：

第一个方面是，第二种的灵活性更高，我们可以随时delete，释放掉这片内存空间。而第一种只能出了块作用域之后才能被释放掉。

第二个方面就是，对于动态数组来说，输入规模n不能确定，这种只能等到输入具体的n，程序具体运行的时候才能知道，只能用第二种方式了。



那什么是静态的呢？

全局变量和被 `static`修饰的变量就是静态的。它们在程序刚开始，还没开始执行命令的时候就已经被分配好了空间，直到程序结束才会被释放掉。这种就是静态的。



我们为什么会用到静态数据成员和静态成员函数呢？接下来一起看看。

举个例子，我们有一个学生类，学生类的对象是一个学生个体，每一个学生类的对象都有自己的学号、姓名、性别等。在实际的应用中，常常还需要一些其他的数据项，比如学生总人数、平均成绩等。

这些数据并不属于学生个体，但是与学生有关。而我们创建对象的时候，每一个对象的这些数据项又属于每个对象。我们希望把这些属于整体对象的数据给单拎出来，跟成员函数一样被所有对象共享。

## 3.6.1静态数据成员

在一个类中，若将一个数据成员说明为`static`，这种成员被称静态数据成员。与一般的数据成员不同，静态数据成员只有一份，为所有对象共享。

```cpp
static 数据类型 数据成员名；
```

```cpp
class Student
{
    public:
    private:
    	char* name;   //姓名
    	char* number;  //学号
    	float score;  //成绩
    	static int count;  //学生人数
    	static float sum;  //学生总成绩
    	static float ave;   //平均成绩
};
int Student::count = 0;        //静态数据成员的初始化必须在类外进行，不能在类内部哦
float Student::sum = 0.0;		//初始化的时候不能加static
float Student::ave = 0.0;		//类外定义的时候要加类名::  哦
```



访问公有静态数据成员的方法有两种：

```cpp
类名::静态数据成员名
对象名.静态数据成员名
对象指针->静态数据成员名
```



私有的静态数据成员不能在类外直接访问，需要借助于公有的数据成员函数。



## 3.6.2静态成员函数

静态成员函数可以访问静态数据成员，但不能访问非静态数据成员。

静态成员函数没有this指针

定义静态成员函数

```cpp
static 返回类型 静态成员函数名（参数表）； //在类内声明的时候加static，在定义函数的时候不要加static
```

调用公有静态成员函数的方法跟上面一样，不写了

静态成员函数的一个重要作用，在建立任何对象之前，可以用静态成员函数来处理静态数据成员。



其实也可以使用静态成员函数来访问非静态成员，只需设定参数为类的对象即可，这样就把对象的地址传了过去，就可以找到该对象的非静态数据成员了，就可以操作了。

# 3.7友元

类的私有成员只能被本类的成员函数访问，但是有时候我们需要在类外访问类的私有成员。为了不破坏类的封装性，我们使用友元开一个小孔，通过友元访问类的私有成员。



## 3.7.1友元函数

友元函数可以是不属于任何类的非成员函数，也可以是另一个类的成员函数。

在类中声明友元函数时，需要在其函数名前加上关键字`friend`，此声明可以放在公有部分，私有部分或者保护部分。都没问题，因为友元函数不是本类的成员函数。

```cpp
class Girl
{
    public:
    friend void disp(Girl &);  //在类中声明disp为Girl类的友元函数
}

void disp(Girl &x)   //定义友元函数的时候不需要friend，也不需要类名::，因为不是类的成员函数
{
    cout << x;   
}
```

友元函数可以访问类对象的各个私有数据，但是访问的时候不能用对象去调用友元函数，只能给友元函数定义类对象的形参，作为参数传入，才能访问到具体对象的私有数据。跟静态成员函数一样。



如果没有友元机制，外部函数访问类的私有数据，只能通过调用公有的成员函数，这在需要频繁调用私有数据的情况下，会带来较大的开销，从而降低程序运行的效率。但是，引入友元机制并不是使数据成为公有或全局，未经授权的其他函数仍然不能直接访问这些私有数据。因此，慎重、合理地使用友元机制不会彻底丧失安全性，不会使软件可维护性大幅度降低。

友元函数会破坏数据的隐蔽性和类的封装性，降低程序的可维护性，因此应该谨慎使用友元函数。



## 3.7.2将成员函数声明为友元函数

除了一般的非成员函数可以作为某个类的友元函数之外，一个类的成员函数也可以作为另一个类的友元函数。

友元成员函数不仅能访问本类的所有成员，还能访问friend声明语句所在类对象中的所有成员。

**一个类的成员函数作为另一个类的友元函数时，必须先定义这个类。**

```cpp
class Girl;        //对Girl类的提前声明----->不能少
class Boy
{
    public:
    	void disp(Girl &);      //声明函数disp为类Boy的成员函数
};
class Girl
{
    public:
    	friend void Boy::disp(Girl &);  //声明类Boy的成员函数为类Girl的友元函数
    									//类名Boy::  不能少！！！
};
```



## 3.7.3友元类

```cpp
class Y
{
    //类体
};
class X
{
    friend Y;            //类Y是类X的友元类
    //类体
}
```

当类Y被声明为类X的友元时，类Y的所有成员函数都成为类X的友元函数。



友元关系是单向的，友元关系不具有传递性。





# 3.8 类的组合

以后再说。



# 3.9常类型

被 `const`修饰的变量在程序运行的过程中值不能被修改。



## 3.9.1常引用

```cpp
const 类型 &引用名;
```

刚看到这个东西的时候，我在想，引用的意义何在？

常引用往往用来作函数的参数

```cpp
int add(const int &i,const int &j);
```

如果不加引用，在开始执行函数的时候，会给形参分配空间，在函数执行结束，释放掉形参分配的空间。而使用引用的话就用不着这一步了，相当于**优化**

## 3.9.2常对象

```cpp
类名 const 对象名[(参数表)];
const 类名 对象名[(参数表)];      //这俩一样的 
```

对象用const修饰，就必须初始化，而且不能被更新。

一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。



## 3.9.3常数据成员

```cpp
const 数据类型 变量名;
```

## 3.9.4常成员函数

```cpp
返回值类型 函数名（参数表） const;  //常成员函数在声明和定义的时候都需要在末尾加上 const
```

```cpp
返回值类型 函数名（参数表） const
{
    //函数体
}
```

