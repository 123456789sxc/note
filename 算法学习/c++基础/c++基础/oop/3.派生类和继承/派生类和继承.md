派生类和继承

# 4.1派生类的概念



类A继承类B，类A称为派生类或子类，类B称为基类或父类。

**类A继承类B的所有成员，包括成员函数和数据成员，除了构造函数和析构函数。**派生类还可以添加一些新的、自己的成员函数和数据成员。



派生类的声明

```cpp
class 派生类名:[继承方式] 基类名
{
	//派生类新增的数据成员和成员函数
}
```



继承方式：private、public、protected

如果不显式地给出继承方式关键字，系统默认为private

继承方式决定了 **派生类成员** 和 **类外对象**  对 **从基类继承来的成员** 的**访问权限**。



派生类不能对 从基类继承来的成员  进行选择，但是可以进行调整：

1. 继承方式
2. 重写

继承方式：

不论继承方式是哪一个，基类的私有成员，不能被派生类成员访问，也不能被类外对象访问。

继承方式是public时，基类的public在派生类还是public，protected还是protected

继承方式是private时，基类的public和protected在派生类中为private

继承方式是protected时，基类的public和protected在派生类中为protected

重写：

**在派生类中声明一个与基类成员同名的成员，则派生类中的成员就会隐藏基类的成员。如果需要在派生类中使用被隐藏的基类成员** `基类名：：成员名`

使用函数名和函数表相同的函数来隐藏基类的成员函数。

这个隐藏就相当于，局部变量隐藏全局变量，要想访问在局部访问全局变量需要使用 `：：`

举个例子

```cpp
class A
{
    public:
    	void print()
        {
            cout << 'A';
        }
};
class B:public A
{
	private:
		void print()
		{
			cout << 'B';
		}
};

int main()
{
    A a;
    B b;
    a.print();   // 输出 A
    b.print();   //无法访问,说明调用的是派生类新增的print函数，说明了对基类print的隐藏。
    b.A::print();   //输出 A
}
```

从基类到派生类可以这样看：

刚开始的时候只有基类的成员，我们开除基类的构造函数和析构函数。

此时基类成员有三类：private、public和protected

我们把private成员关进小黑屋，全密闭，从此以后与世隔绝不能进不能出。

根据给定的继承方式把剩下基类的public和protected 分到 派生类的三类中，从此以后就将作为派生类的成员生存。

如果有重写隐藏就重写隐藏，可选。

最后，让新的成员入住。



protected只有在上述过程有存在的意义，其余时候看成private就可以了。👇

如果只关注一个类，就不需要分protected和private





# 4.2 派生类构造函数和析构函数

派生类中不含基类的构造函数和析构函数。 从基类中继承下来的成员的初始化由基类的构造函数完成。派生类新增的成员的初始化由派生类的构造函数完成。

在创建派生类对象的时候，首先执行基类的构造函数，然后执行派生类的构造函数。当撤销对象的时候，先执行派生类的析构函数，在执行基类的析构函数。



派生类构造函数的一般格式：

```cpp
派生类名（参数表1）：基类名（参数表2）
{
	//派生类新增数据成员的初始化语句
}
```



参数表1是形参表，就是在创建派生类对象的时候实参传入到该形参表。

冒号: 后面的  `基类名（参数表2）`  是调用语句，调用基类的构造函数。**参数表2的参数是实参**。

如果基类的构造函数 不需要参数，那么  `：基类名（参数表2）` 可以省略。



说明：

1. 如果派生类构造函数采用 类内声明，类外定义的形式。那么在类内声明的时候不需要 `：基类名（参数表）`

   在类外定义的时候需要。

2. 当基类的构造函数有参数，而派生类的构造函数不需要参数的时候，派生类的构造函数即使函数体为空，也要按照上面的形式显式定义出来



析构函数没有构造函数复杂，在派生类中直接定义析构函数就可以了。



# 4.3多重继承







































































