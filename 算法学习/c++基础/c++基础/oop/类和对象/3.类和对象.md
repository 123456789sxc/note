第三章 类和对象

# 3.1类与对象的基本概念

## 3.1.1结构体和类

### 1.结构体的扩充

结构体是c语言一种自定义的数据类型，在结构体中可以含有不同类型的数据。

在c++中对结构体进行了扩充，不仅可以就含有不同类型的数据，而且还可以含有函数。

我们称结构体中的变量为数据成员，称结构体中的函数为成员函数

下面举一个例子来说明结构体的使用方法

```cpp
struct Complex{   //声明了一个名为Comeplex的结构体，表示复数
    double real;   //复数的实部
    double imag;   //复数的虚部
    void init(double r,double i)   //结构体的初始化函数
    {
        real = r;
        imag = i;
    }
    double abs()                   //求复数的绝对值
    {
        double t;
        t = real*real+imag*imag;
        return sqrt(t);
    }
}

int main()
{
    Complex A;
    A.init(1.1,2.2);
    cout << A.abs();
}
```



注意：这只是结构体的简单使用，其实结构体和类的区别很小。

结构体和类有什么区别？

结构体被设计出来的目的是为了存储一组相关的数据；而类被设计出来的目的是

通过将一组相关的数据和函数放在一个类中，可以使代码更加模块化和可维护。类可以将数据和函数封装起来，防止数据被不合理地修改，同时提供更好的数据安全性和访问控制。类还可以支持继承和多态，使得代码更加灵活和可扩展。

但是c++扩展之后，结构体相当于类的一个对称。

### 2.类的声明

c++提供了另一种用户自定义的数据类型——类。

```cpp
//类声明的一般形式

class 类名
{
    [private:]
    	数据成员和成员函数
    public:
    	数据成员和成员函数
    protected:
    	数据成员和成员函数
}
```

类将数据成员和成员函数分为三类，private、public和protected，私有和共有。

对于私有成员来说，它们只能被本类的成员函数看得到，即能够被本类的成员函数访问。

对于公有成员来说，它们不仅可以被本类的成员函数访问，也能被该类的对象访问

对于保护成员来说，它们可以被本类的成员函数访问，也能被本类的派生类的成员函数访问。

> 综上可知，在类的内部，类中的任何成员 都可以被 本类的成员函数访问。

**访问就是能被看见，能被使用。**

> 结构体也有同样的性质👆

```cpp
struct 结构体名
{
    [public:]
    	数据成员和成员函数
    private:
    	数据成员和成员函数
}
```



在结构体中，如果对其成员不作private和public的声明，默认为public;在类中，默认为private



## 3.1.2成员函数的定义形式

成员函数有三种定义形式：

1. 类外定义，类内声明
2. 类内定义，隐式内联
3. 类外定义，显示定义为内联，类内声明

```cpp
class Point
{
    public:	
    	void setpoint(int a,int b);   //类内声明成员函数
    private:
    	int x,y;
}

void Point::setpoint(int a,int b)    //类外定义
{
    x = a;
    y = b;
}
```

这种类外定义，类内声明的方式减少类体的长度，使类的声明简洁明了，便于阅读。

```cpp
class Point
{
    public:
    	void setpoint(int a,int b)   //类内直接定义，隐式内联
        {
            x = a;
            y = b;
        }
    private:
    	int x,y;
}
```



```cpp
class Point
{
    public:	
    	void setpoint(int a,int b);   //类内声明成员函数
    private:
    	int x,y;
}

inline void Point::setpoint(int a,int b)    //类外定义,显式内联
{
    x = a;
    y = b;
}
```

> 跟结构体一样



## 3.1.3对象的定义和使用

### 1.类和对象的关系

类和对象的关系相当于，数据类型和变量名之间的关系。

### 2.对象的定义

定义对象的两种方法：

1. 声明类的同时定义对象
2. 类声明之后，定义对象

> 跟结构体一样

```cpp
class Point
{
    public:
    	void setpoint(int,int);
    private:
    	int x,int y;
}op1,op2;   //声明类的同时定义了两个该类的对象
```

### 3.对象对成员的访问

对象只能对类的公有成员进行访问，有以下三种方法：

1. 通过点运算符 `对象名.数据成员名`  `对象名.成员函数名()`
2. 通过 `->` ，指向对象的指针
3. 通过 \*号和 点运算符 `(*p).数据成员`



# 3.2构造函数和析构函数

1. 我们声明变量的时候常常会进行初始化，如果不进行初始化的话，取值就是随机的。

   同样，我们声明对象也会对对象的数据成员进行初始化。

2. 另一方面，我们声明变量的时候会给变量分配内存空间，{}结束时或遇到delete时会释放空间

   ```cpp
   int i;   //程序编译时分配给变量i 一个int的空间,在{}结束时被释放,变量i被删除。
   ```

   ```cpp
   int *a = new int[n];  //程序运行时被分配给变量i n个连续的int的空间
   //遇到delete a;时n个连续的int空间被释放，指针a直到{}结束时被删除
   ```

   

   同样，我们声明对象的时候，也会给对象的数据成员分配空间，{}结束时或遇到delete时会释放空间

   

在c++中，每一个类都有自己的构造函数和析构函数，这两个函数可以由用户自定义，也可以由系统生成。如果用户没有定义构造函数和析构函数，系统就会生成默认的构造函数和析构函数。如果至少存在一个构造函数，系统就不再提供默认的构造函数，为什么是 “存在至少一个”，因为构造函数可以重载。析构函数不同，一个类中只能有一个析构函数。

对于默认的构造函数和析构函数，不带任何参数，函数体是空的，只能为对象分配内存空间和释放内存空间。

构造函数会在声明类的对象的时候自动调用。构造函数用来为类的对象分配空间和进行初始化。构造函数是在声明对象的时候自动调用，我们在定义构造函数的时候可以不止为对象分配空间和进行初始化，还可以进行一些其他的操作。

析构函数会在对象被释放的时候自动调用。析构函数用来释放掉对象占用的内存。

3. **当类的数据成员中存在需要动态分配内存的变量时**，我们必须自定义构造函数，给其分配内存空间，在析构函数中释放掉。不能使用默认的构造函数和析构函数

## 3.2.1对象的初始化和构造函数

类是一种数据类型，不占存储空间，因此不能在类声明中给数据成员赋初值。

如果一个类的所有数据成员都是公有的，可以这样做

```cpp
class Complex
{
    public:
    	double real;
    	double imag;
};

Complex c = {1.1,2.1};
```

只要有数据成员不是公有的，就不能用这种方法。

也可以使用类的公有成员函数进行初始化

```cpp
class Complex
{
    public:
    	void init(double ,double );
    	double real;
    	double imag;
};

void Complex::init(double a,double b)
{
    real = a;
    imag = b;
}
int main()
{
    Complex c;
    c.init(1.1,2.1);
    cout << c.real << ' ' << c.imag;  // 1.1   2.1
}
```

c++提供了更好的方法，使用构造函数

如果我们不自定义构造函数和析构函数的话，默认的构造函数和析构函数的权限修饰符是public，因此，我们自定义构造函数和析构函数的话也要是public，不能是private，因为这样在声明对象的时候就不能调用构造函数了。

**构造函数的名字必须与类名相同，可以有任意类型的参数，但是不能有返回值。**

```cpp
class Complex
{
    private:
    	double real,imag;
   	public:
    	Complex(double r,double i)   //构造函数也是成员函数，定义成员函数有三种方法，这里取其中一种
        {
            real = r;
            imag = i;
        }
};

int main()
{
    Complex c(1.1,2.1);
    Complex *p = new Complex(1.1,2.1);
    //声明对象和初始化的两种方法👆
}
```

不带参数的构造函数对对象的初始化是固定的

```cpp
class Complex
{
    private:
    	double real,imag;
   	public:
    	Complex()
        {
            real = 0;
            imag = 0;
        }
};
```



## 3.2.2用成员初始化列表对数据成员初始化

举个具体的例子

```cpp
class Complex
{
    private:
    	double real;
    	double imag;
    public:
    	Complex(double r,double i):real(r),imag(i){}
};


```

其中 `：real(r),imag(i)` 就是成员初始化列表。冒号后面跟 `数据成员名(初始值),数据成员名(初始值),...`

成员初始化列表只能在构造函数中使用，在其他成员函数和类外都不能使用

成员初始化列表写法方便简练、更装逼。但其实也是有实际用途的。

对于c++的某些类型的成员，不能用赋值语句赋值，比如 引用类型，const修饰的数据成员。这时候就要用成员初始化列表了。

数据成员的初始化是按照它们在类中声明的顺序进行的。举例：

```cpp
class D
{
    public:
    	D(int i):mem2(i),mem1(mem2+1)
        {
            cout << "mem1" << mem1 <<endl;
            cout << "mem2" << mem2 << endl;
        }
    private:
    	int mem1;
    	int mem2;
};

int main()
{
    D d(15);
}

输出结果：
mem1: -858993459
mem2: 15
```

**其实看成员初始化列表会觉得是先给mem2赋初值，再给mem1赋初值。实际上是根据数据成员在类中的声明顺序进行的初始化**。因此正确的初始化顺序是先给mem1赋初值，再给mem2赋初值。这样就可以解释的通了，因为在给mem1赋初值的时候，mem2还没被初始化。



## 3.2.3构造函数的重载



## 3.2.4带默认参数的构造函数

不建议用，别用这玩意儿，给自己找麻烦，没需求不要创造需求。



## 3.2.5析构函数

析构函数与类名相同，但是必须在它前面加一个波浪号(~）

析构函数没有返回值

析构函数没有参数，不能重载

释放对象的时候会自动调用析构函数

如果在对象释放之前需要完成一些工作的话，可以显式定义析构函数，并写入到析构函数中，比如delete在构造函数中new分配的内存空间。

```cpp
class String_data
{
    public:
    	String_data(char* s)
        {
            str = new char[strlen(s)+1];
            strcpy(str,s);
        }
    	~String_data()
        {
            delete str;
        }
    private:
    	char *str;
}
```



# 3.3对象数组和对象指针和this指针



# 3.4向函数传递对象



