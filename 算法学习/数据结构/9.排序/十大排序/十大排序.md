1.1 冒泡排序

```c++
void Bubble_sort(int a[],int n)
{
    for(int i = 1;i < n - 1;i++)
    {
        
    }
}
```



快速排序

简称快排，双指针算法

算法思路：

1. 选择一个基准元素（pivot）：从待排序的数组中选择一个元素作为基准元素。通常情况下，可以选择第一个元素、最后一个元素或者随机选择一个元素作为基准元素。
2. 分割过程：**将数组中比基准元素小的元素放在基准元素的左边，比基准元素大的元素放在基准元素的右边。**这个过程称为分割（partitioning）。具体操作可以使用两个指针（一前一后）从数组的两端开始，不断交换元素直到它们相遇，同时将比基准元素小的元素放在左边，大的元素放在右边。
3. 递归排序：对分割后的左右两个子数组进行递归排序。将基准元素左边的子数组和右边的子数组分别应用快速排序算法。

有三种思路：挖坑、左右指针、快慢指针

这里写两个：挖坑和左右指针

挖坑要求基准数选择最左端的数或最右端的数，这里以最左端的数作为基准数举例

```cpp
void quick_sort(int s[],int left,int right)
{
    //根据最后两行参数的确定，left和i-1有可能i-1<left 这里注意不要把条件写成 left == right
    if(left > right) return;
    
    int temp = s[left]; //基准数为数组最左端的数，保存到temp变量中，挖好坑了。
    int i = left,j = right;
    while(i < j)
    {
        //从右边开始找，找到一个小于基准值的数，然后j指针不动
        while(s[j] > temp && i < j) j--;
        //while的结束条件是找到了小于基准值的数或者i==j了
        if(i < j)
        {
            s[i] = s[j];  //if条件是要求，必须找到了小于基准值的数才能填坑
            i++;  // i当前的坑已经被填上了，i跑到下一个位置，开始找大于基准值的数填s[j]这个坑
        }
        while(s[i] < temp && i < j) i++;
        if(i < j)
        {
            s[j] = s[i];
            j--;
        }
    }
    s[i] = temp;
    //不用担心，每次递归都是在原数组上操作，这样递归完就已经排好序了。
    quick_sort(s,left,i-1);
    quick_sort(s,i+1,right);
}
```

<font size =5>妈的，超时了</font>

左右指针法：

> 1、取数组的第一个数/最后一个或者中间数或者随机数为基准数。(这里取中间数，因为中间数比取两边更快)
> 2、设置两个变量left = 0;right = N - 1;
> 3、定义指针 i = left,j = right;
>
> 从i一直向后走，i++,直到找到一个大于或等于基准数的值，right从后至前，j--,直至找到一个小于或等于基准数的值，然后交换这两个数，然后i，j同时往中间移动一次。
> 4、重复第三步，直到i和j相遇。以相遇点i为界，将原数组划分为[left,i],[i+1,right]，分别进行新的快排
>
> 注意：这里的划分点是以相遇点进行划分，不是基准数的位置，基准数并不一定是在相遇点。相遇点左边的数一定是小于或等于基准数，相遇点右边的数一定是大于或等于基准数。
>
> 注意区间的划分，首先相遇点的值也要加入到子数组中进行排序。跟填坑法不一样。
>
> 其次，当我们选择数组中间点或者最左端作为基准值的时候，区间必须要划分成【left，i】和【i+1，right】
>
> 选择数组右端点作为基准值的时候，区间必须划分成【left，i-1】和【i，right】
>
> 因为考虑数组中只有两个数的时候，当我们基准值取的是最左端或数组中点的时候，这两个数中左边的那个数就是基准值，最后一步相遇点在左端点，如果按照【left，i-1】和【i，right】划分的话，左边的划分是空；而右边还是这两个数组，会如此重复下去导致一直递归进入子程序，栈溢出，显示的错误就是MLE

```cpp

```



```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;  //区间没有数或只有一个数的时候停止

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```

