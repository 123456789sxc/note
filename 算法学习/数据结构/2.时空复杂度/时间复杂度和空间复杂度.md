时间复杂度和空间复杂度

[时间复杂度和空间复杂度（详解版） (biancheng.net)](http://c.biancheng.net/view/8081.html)

什么是算法？

算法是解决某个问题的思路。

一个算法在能保证真正解决问题的前提下，我们要衡量算法的运行效率，也就是性能

程序的运行效率具体可以从 2 个方面衡量，分别为：

- 程序的运行时间。
- 程序运行所需内存空间的大小。

根据算法编写出的程序，运行时间更短，运行期间占用的内存更少，该算法的运行效率就更高，算法也就更好。

每一位初学者都要掌握一个技能，即善于运用时间复杂度和空间复杂度来衡量一个算法的运行效率。

 判断一个算法所编程序运行时间的多少，并不是将程序编写出来，通过在计算机上运行所消耗的时间来度量。原因很简单，一方面，解决一个问题的算法可能有很多种，一一实现的工作量无疑是巨大的，得不偿失；另一方面，不同计算机的软、硬件环境不同，即便使用同一台计算机，不同时间段其系统环境也不相同，程序的运行时间很可能会受影响，严重时甚至会导致误判。

实际场景中，我们更喜欢用一个估值来表示算法所编程序的运行时间。所谓估值，即估计的、并不准确的值。注意，虽然估值无法准确的表示算法所编程序的运行时间，但它的得来并非凭空揣测，需要经过缜密的计算后才能得出。  

**如何预估一个算法所编程序的运行时间呢？很简单，先分别计算程序中每条语句的执行次数，然后用总的执行次数间接表示程序的运行时间。**

以一段简单的 C 语言程序为例，预估出此段程序的运行时间：

```c
for(int i = 0 ; i < n ; i++)     
{
    a++;              
}
```

在上面这段代码中， `int i = 0`执行了一次；for循环里的条件判断语句 `i<n` 执行了 $n+1$次；`a++`执行了$n$次；`i++`执行了n次。总执行次数为 $1+(n+1)+n+n=3*n+2$

再举一个例子：

```c
for(int i = 0 ; i < n ; i++)     
{ 
    for(int j = 0 ; j < m ; j++)     
    {
        num++;                    
    }
}
```

先算内层循环，内层循环就是第一个例子，所以一次内层循环执行次数为 $3*m+2$;外层循环：`int i = 0`执行了一次;for循环里的条件判断语句执行了$n+1$次，`i++`执行了$n$次，内层循环执行了$n$次，一次内层循环执行次数为$3*m+2$,因此这段代码总执行次数为$1+(n+1)+n+n*[3*m+2]=3*n*m+4*n+2$ 



我们衡量一个程序的好坏，更多的是看程序在最坏情况下的运行时间，在上面的例子中，就是让数据规模$n,m$趋于无穷大，当$n,m$趋于无穷大的时候，代码总执行次数由更高阶的$n*m$决定，即当$n,m$趋于无穷大时，$3*n*m+4*n+2 = n*m$,即乘数3和常数2，以及低阶的$4*n$并不影响结果。因此，我们可以将这段代码的总执行次数简化为 $n*m$

然后写成这样的形式 $O(n*m)$ 来表示这段代码的时间复杂度。(不要问为什么用这样的形式，记住就行了)



空间复杂度

要知道每一个算法所编写的程序，运行过程中都需要占用大小不等的内存空间，例如：

- 程序代码本身所占用的内存空间；
- 程序中如果需要输入输出数据，也会占用一定的内存空间；
- 程序在运行过程中，可能还需要临时申请更多的内存空间。

对于第一个因素，可以把代码写短点，占用的空间就少了，但是对于空间复杂度的影响几乎为0，这个东西不要考虑；第二个跟具体问题的输入输出要求有关，对空间复杂度的影响也可以忽略不计；**因此，我们只需要考虑程序运行过程中申请的空间和输入规模$n$的关系就可以了。**



举个例子：

```c
int n;
scanf("%d", &n);
int a[10];
```

这段程序在运行时所申请的临时空间，并不随 n 的值而变化。

再举一个例子：

```c
int a[n];
```

程序运行所申请的临时空间，和 n 值有直接的关联。

在第一个例子中，n的变化不影响申请的内存空间的变化，因此空间复杂度为O(1)

在第二个例子中，随着输入值 n 的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n) 表示;



我觉得衡量一个算法，在一般的情况下，往往更看重的是时间复杂度，即希望算法运行的时间尽可能短，这样往往会需要更多的空间，即用空间来换时间。

我们来看一个题目：

第一行输入$n,m$，接下来输入n行，每一行有m个数。数据范围$1 \leq n,m \leq 100$ 

要求二维数组来存储这个矩阵。

有两种写法：

1. 根据数据范围申请一个静态二维数组

```cpp
# include <cstdio>    //scanf和printf在输入输出很多的时候运行的时间低于cin和cout，输入输出少的时                         //候，运行时间差不多
using namespace std;

const int N = 110;    //数据范围是100,多开10个防止溢出
int matrix[N][N];    //二维数组为全局变量，自动初始化使其元素全为0。比写到main函数里好，不用再初始化了

int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    for(int i = 0;i<n;i++)
        for(int j = 0;j<m;j++)
            scanf("%d",&matrix[i][j]);
}
```

2. 构造动态二维数组

```cpp
#include <cstdio>

using namespace std;

int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    int **s = new int*[n];
    for(int i = 0;i<n;i++) s[i] = new int[m];
}
```



第一种方法来说，虽然对于有某些实例来说，造成了空间浪费，但是相较于第二种方法，所消耗的时间更短，因为不用在开辟数组这个地方浪费时间。因此，第一种方法明显是比第二种好的，跟着y总也算是学到了一点皮毛。





















