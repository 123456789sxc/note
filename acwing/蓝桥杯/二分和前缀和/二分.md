二分查找

> 真正学会一样东西，是能够有条理地讲述教授给他人,并总结和简化所学内容

二分查找，也称折半查找，是一种查找方法。

使用二分查找的前提条件：

待查找的数列是按照一定的顺序排列的.(最简单的一种排序方式：升序)

二分查找的例题

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例一：

> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4

二分查找的思路：

**已知待查数组nums的长度n以及排序方式(这里以升序举例),要查找的目标值target,**现在要找到待查数组中是否存在target，如果存在求出target在nums中的下标。

- **确定查找区间 $[l , r]$**：定义数组nums最左边下标 l = 0,最右边下标 r =  n-1，中间位置的下标 m = (l+r)/2;  
- 判断nums的中间元素的值 nums[m] 和target的大小
  - 如果相等，返回结果
  - 如果target比中间元素值大，根据升序排序可知，target的位置在中间元素的右侧,数组左半部分就不要了
    - 即让 l = m + 1； 更新查找区间
  - 如果target比中间元素小，则右半部分不要了
    - 即让 r = m - 1；更新查找区间
- 此时更新 m ，继续执行第二步。
- 执行结束的条件是什么呢？
  - 要么找到了，即nums[m] == target ，返回结果，执行结束
  - 要么没找到，根据重复执行的过程，执行到最后，会只剩两个数，此时中间位置的下标 m = ( l+r ) / 2;根据计算机对整数除法的计算规则(向下取整),可知target跟左边那个数进行比较
    - 如果target比左边那个数大，执行 l = m+1; 此时  l == r  ，**还剩一个数没有判断，循环还没结束**
      - 此时中间位置m更新，l == r == m，只剩一个数，这个数跟target进行比较
        - 如果target比这个数大，执行 l = m+1;  此时 l  > r  ，全都判断完了，循环结束
        - 如果target比这个数小，执行 r = m -1；此时 l > r
    - 如果target比左边那个数小，执行 r = m -1；  此时 l == r
      - 与上面情况相同。
  - 由上可知，循环的条件是   while(l <= r)

```c++
void binary_search(int sums[],int n,int target)
{
    int l = 0,r = n-1,m;
    while(l <= r)    //循环结束条件  l > r
    {
        m = (l + r) / 2;
        if(nums[m] == target)
        {
            cout << "m";
            return;
        }
        if(target > nums[m]) l = m + 1;
        else r = m - 1;
    }
    cout << "Not found";
}
```



上面这种算法适用于  找到一个target目标值就完成  的情况。

如果有序数组nums中有多个target目标值，要求找出target序列的左右端点，该怎样使用二分查找来实现呢？

**简要思路：分别使用二分查找法 找出target序列的左右端点。**

![1679126049093](二分.assets/1679126049093.png)



//再进一步之前，我想插一句， 当**待查总数n**是奇数的时候，中间位置就是最中间那个数。当 n 是偶数的时候，中间位置会有两个数，因为 $m = (l + r) / 2$  ,  整数除法向下取整 的原因，   下标m指的是中间那两个数的左边那一个数。$m = (l + r) / 2$ 记住这个结论。后面要用到

- 考虑左端点 

  - 定义查找区间 l = 0 , r = n - 1;  m = (l + r) / 2 ;  

  - 判断 中间元素值 和 左端点的target 的大小

    - 情况一：如果中间元素值nums[m]  大于 target

      - 说明整个target序列在中间值的左边， 更新区间 r = m - 1;

    - 情况二: 如果中间元素值nums[m] 小于target

      - 说明整个序列在中间值的右边，更新区间  l = m + 1；

    - 情况三: 如果中间元素值nums[m] == target

      - **说明左端点在中间元素值的左边或者左端点就是中间元素值  ，更新区间  r = m**

        //注意这种情况因为中间元素值有可能是左端点，所以 不能 让 r = m -1，因为每次查找的区间是 $[l,r]$ 闭区间，如果r = m - 1就会导致找不到左端点。

  - 更新区间后，更新 m ，继续执行第二步

  - 什么时候循环结束呢？这是一个复杂的思考过程。

    - 情况三是一定会发生，在这种情况下，中间元素值 ==  target， r = m 一定会执行，即查找区间的右端点更新到target这个位置

      - 如果查找区间的右端点就是 target序列的左端点，这种情况是很好理解的，接下来的步骤就是一直执行情况二，更新查找区间的左端点，最终查找区间的左端点和右端点重合，此时 l == r

      - 如果查找区间的右端点不是 target序列的左端点，接下来，会多次执行情况二和情况三，只会出现下面两种情况

        - **查找区间的左端点在序列区间的左端点**，这时候多次执行情况三，更新m，最终会形成下面这种局面：查找区间的左端点在序列区间的左端点，查找区间的右端点在序列区间的左端点的右旁边。

          - 这时候因为只剩下两个数，继续更新m，此时m就会指向左边那个数，这样 再次执行 r = m，此时  l == m ，循环结束
          - **在这里你能不能发现一个特殊的地方，如果m 定义为 (l + r + 1) /2   会怎么样呢？**
            - **这样的话，并不影响前面的过程，依旧会到只剩两个数的情况，此时m就会指向右边那个数，这样再次执行 r = m ，会导致 查找区间右端点并没有变化，也就导致死循环。**

        - 另一种情况就是上面提到的查找区间右端点是target序列左端点。

          

我们来写一写代码吧

```c++
void binary_search_left_node(int nums[],int n,int target) //二分查找左端点
{
    int l = 0,r = n - 1,m;
    while(l < r)  // l == r时循环结束
    {
        m = (l + r) / 2;
        if(nums[m] > target) r = m - 1;
        else if(nums[m] < target) r = m + 1;
        else r = m;
    }
}
```

其实num[s] > target 的情况可以跟 nums[m] == target 的情况合并，如下所示 

```c++
void binary_search_left_node(int nums[],int n,int target) //二分查找序列左端点
{
    int l = 0,r = n - 1,m;
    while(l < r)  // l == r时循环结束
    {
        m = (l + r) / 2;
        if(nums[m] < target) r = m + 1;
        else r = m;     //当 nums[m] >=  target 时， r = m
    }
}
```

区别在于，前者当 nums[m] > target 时 ，r = m -1 ，后者  变成了  r = m



现在考虑右端点

- 考虑右端点

  - 定义区间 l = 0 ,r = n - 1, m = (l + r) /2;

  - 判断 中间元素值 和 左端点的target 的大小

    - 情况一：如果中间元素值nums[m]  大于 target
      - 说明整个target序列在中间值的左边， 更新区间 r = m - 1;
    - 情况二: 如果中间元素值nums[m] 小于target
      - 说明这个序列在中间值的右边，更新区间  l = m + 1；
    - 情况三: 如果中间元素值nums[m] == target
      - **说明右端点在中间元素值的右边或者右端点就是中间元素值  ，更新区间  l = m**

  - 现在考虑最后的两种情况：

    - 查找区间的左端点位于序列的右端点，此时多次执行，r = m - 1，最终 l == r
    - 查找区间的右端点位于序列的右端点，最终会出现下面这种情况，查找区间的左端点在序列右端点的左旁边
      - **这种情况，因为 m指向的是两数的左边那个数，会执行 l = m，即 左端点不动，这样就会陷入死循环，解决办法，让 m = (l + r + 1) / 2,这样的话，m指向的就是两数的右端点，再执行l = m时，l == r 了，循环就可以结束了。**

    **总结，m的取值，只有在最后只剩两个数的时候才会发挥作用。**



看看代码

```c++
void binary_search_right_node(int nums[],int n,int target) //二分查找序列右端点
{
    int l = 0, r = n-1,m;
    while(l < r) // l == r循环结束
    {
        m = (l + r + 1) / 2;
        if(nums[m] > target) r = m - 1;
        else l = m;
    }
}
```



总结：

本次学习了二分查找的两类使用

1. 在只含有一个target的排序数组中，找到这个target的下标
2. 在含有target序列的排序数组中，找到target序列，即找到序列的左右端点。

确定是两类使用吗？哈哈，其实无论是找序列的左端点还是找右端点，都可以满足第一种情况。



```c++
void binary_search_left_node(int nums[],int n,int target) //二分查找序列左端点
{
    int l = 0,r = n - 1,m;
    while(l < r)  // l == r时循环结束
    {
        m = (l + r) / 2;
        if(nums[m] < target) r = m + 1;
        else r = m;     //当 nums[m] >=  target 时， r = m
    }
}


void binary_search_right_node(int nums[],int n,int target) //二分查找序列右端点
{
    int l = 0, r = n-1,m;
    while(l < r) // l == r循环结束
    {
        m = (l + r + 1) / 2;
        if(nums[m] > target) r = m - 1;
        else l = m;
    }
}
```



根据上面所理解的来记忆代码模板：

记住两个概念，查找区间 和 序列区间

**如果我们要找序列左端点**，最终会面临两种情况：

- 一种情况是 **查找区间的右端点位于序列区间的左端点**，这时候，只要让查找区间的左端点一直往右移动即可
  - 即 `if(nums[m] < target) r = m + 1 ;`

- 另一种情况就是 **查找区间左端点位于序列区间的左端点，查找区间的右端点在其旁边**，即只考虑两个数的情况，此时因为我们的查找区间左端点位于序列区间的左端点，只要让查找区间的右端点移动到这个位置就好了
  - 考虑两件事:
  -  m 要指向两数中左边那个数，即 `m =  (l + r) / 2;`
  - 右端点移动： `r = m`

这样我就可以默写出来查找序列左端点的模板代码了

```c++
void binary_search_left_node(int nums[],int n,int target) //left
{
    int l = 0,r = n - 1,m;
    while(l < r)
    {
        m = (l + r) / 2;
        if(nums[m] < target) r = m + 1;
        else r = m;
    }
}
```





















